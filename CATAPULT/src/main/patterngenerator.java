package main;

import java.io.BufferedInputStream;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.PriorityQueue;

import adjlistgraph.Graph;
import andyfyp.DnDImage;
import andyfyp.ThumbnailTable;
import extendedindex.ExFreqIndex;
import extendedindex.ExIndex;
import frequentindex.Vertex;
import graph.JGraphtClosureGraph;
import graph.VF2;
import graph.closureEdge;
import graph.closureVertex;
import result.DotGenerator;
import graph.DBStat;
import graph.DBStatComparator;
import thread.CollapsePatternThread;
import thread.CollapsePatternThreadCompleteListener;
import thread.ComputeScoreThread;
import thread.ComputeScoreThreadCompleteListener;
import thread.GenerateClosureThread;
import thread.GenerateClosureThreadCompleteListener;
import thread.GeneratePatternThread;
import thread.GeneratePatternThreadCompleteListener;

public class patterngenerator {
	private String pubchem = "pubchem";
	private String emolecule = "emolecul";
	private String AIDS = "AIDS";
	private String AIDS10k = "AIDS10k";
	private String AIDS40k = "AIDS40k";
	private int PATTERN_MAX_SIZE = 20;
	private boolean FULLY_UNCOVERED_LIST_IS_EMPTY = false;
	// private TreeTransferHandler treeTransferHandler; //data carrier <- (export,
	// import)
	private ExIndex exIndex;
	private ExFreqIndex exFreqIndex;
	private ArrayList<String> patternSetVertexLabels = new ArrayList<String>();
	private ArrayList<String> patternSetEdgeLabels = new ArrayList<String>();

	// 1. Generated by readClusterFile()
	private ArrayList<Integer> fullyContainedGraphID = new ArrayList<Integer>();// all graphs in clusters

	// 2. Generated by PM_generateClusterClosure()
	private ArrayList<JGraphtClosureGraph> closureGraphList = new ArrayList<JGraphtClosureGraph>();
	private ArrayList<Integer> closureGraphIndexList = new ArrayList<Integer>();
	private int maxClosureSize = 0;
	private ArrayList<Float> c_wt = new ArrayList<Float>(); // weight of closure graph. initialized by % of graphs in
															// cluster and updated using multiplicative weights update
	// information about the DB that is used to improving pattern mining. Sorted in
	// decreasing frequency
	private ArrayList<String> DBEdgeLabel = new ArrayList<String>();
	private ArrayList<Integer> DBEdgeLabelFreq = new ArrayList<Integer>();
	private ArrayList<Float> DBEdge_wt = new ArrayList<Float>();
	private ArrayList<String> DBVertexLabel = new ArrayList<String>();
	private ArrayList<Integer> DBVertexLabelValency = new ArrayList<Integer>();

	private ArrayList<ArrayList<closureEdge>> distinctCandidatePatterns = new ArrayList<ArrayList<closureEdge>>();
	private ArrayList<ArrayList<Integer>> distinctCandidatePatterns_closureIndex = new ArrayList<ArrayList<Integer>>();

	// --------------------------------------------------------------------------
	private VF2 VF2_operator = new VF2();
	private ArrayList<ArrayList<closureEdge>> candidatePatterns = new ArrayList<ArrayList<closureEdge>>();
	private ArrayList<Integer> candidatePatterns_closureIndex = new ArrayList<Integer>();
	// --------------------------------------------------------------------------
	private int CSI_A;
	private ArrayList<Double> distinctCandidatePatterns_score = new ArrayList<Double>();
	private DotGenerator dotGenerator = new DotGenerator();

	private String DBName;
	private int minCannedPatternSize = 3;
	private int maxCannedPatternSize = 12;
	private int numCannedPatterns;

	private String dbName = AIDS;
	private int dbSize = 40;
	private int GUISize = 30;

	public static void main(String[] args) throws IOException {
		// TODO Auto-generated method stub
		patterngenerator gen = new patterngenerator();
		gen.generatePatterns();
	}

	public void generatePatterns() throws IOException {
		ArrayList<ArrayList<Integer>> original_clusterIDList = new ArrayList<ArrayList<Integer>>();// graph ids in
																									// clusters
		ArrayList<ArrayList<closureEdge>> GUIPatterns = new ArrayList<ArrayList<closureEdge>>();
		System.out.println("start generating pattern");
		Long generatePatternStartTime = System.currentTimeMillis();
		{
			// 1. read the cluster.txt file first
			System.out.println("STEP 1: reading cluster file");
			fullyContainedGraphID = new ArrayList<Integer>();
			System.out.println("dbName:" + dbName + " dbSize:" + dbSize);
			String filename;
			if (dbName.compareTo("AIDS") == 0) {
				// original_clusterIDList=readClusterFile("data/"+dbName+"/"+dbSize+"kcluster.txt");
				//original_clusterIDList = readClusterFile("data/" + dbName + "/" + "cluster20000.txt");
				//filename = "data/" + dbName + "/" + dbName + dbSize + "k";
				original_clusterIDList = readClusterFile("Clusters/clusters.txt");
				filename = "AIDS40k";
			} else {
				//original_clusterIDList = readClusterFile("data/" + dbName + "/cluster.txt");
				//filename = "data/" + dbName + "/" + dbName;
				original_clusterIDList = readClusterFile("Clusters/clusters.txt");
				filename = "AIDS40k";
			}
			// for(int i=0; i<original_clusterIDList.size(); i++)
			// System.out.println("cluster "+i+":
			// "+original_clusterIDList.get(i).toString());

			// 2. for each cluster, read the graphs of these clusters then generate the
			// closure graph
			// int totalGraphs=PM_generateClusterClosure(original_clusterIDList);
			int totalGraphs = PM_generateClusterClosure(filename, original_clusterIDList);
			// output the closure graphs to the folder
			/*
			 * String pathToSaveImage = PM_resetThumbnailFolder();
			 * ArrayList<ArrayList<closureEdge>> closureGraphs=new
			 * ArrayList<ArrayList<closureEdge>>(); for(int i=0; i<closureGraphList.size();
			 * i++) { JGraphtClosureGraph cG=closureGraphList.get(i);
			 * closureGraphs.add(cG.getClosureEdgeList()); }
			 * PM_generateThumbnails(pathToSaveImage, closureGraphs);
			 * PM_loadThumbnails(pathToSaveImage);
			 */
			// initialize c_wt and DBEdge_wt
			for (int i = 0; i < original_clusterIDList.size(); i++)
				c_wt.add((float) original_clusterIDList.get(i).size() / (float) maxClosureSize);
			System.out.println("totalGraphs [here]=" + totalGraphs);
			for (int i = 0; i < DBEdgeLabel.size(); i++)
				DBEdge_wt.add((float) DBEdgeLabelFreq.get(i) / (float) totalGraphs);
			System.out.println("DBEdgeLabelFreq=" + DBEdgeLabelFreq.toString());
			System.out.println("DBEdge_wt=" + DBEdge_wt.toString());
			// System.out.println("c_wt: "+c_wt.toString());
			// System.out.println("DBEdge_wt: "+DBEdge_wt.toString());
			// int GUISize=patternSetInfo.getFreqNum();
			ArrayList<Integer> GUIPatternSizeCounter = new ArrayList<Integer>();
			ArrayList<Integer> GUIPatternSize = new ArrayList<Integer>();
			// for(int i=patternSetInfo.getPatternSizeMin();
			// i<=patternSetInfo.getPatternSizeMax(); i++)
			for (int i = minCannedPatternSize; i <= maxCannedPatternSize; i++) {
				GUIPatternSize.add(i);
				GUIPatternSizeCounter.add(0);
			}
			boolean PRINT = false;
			for (int g = 0; g < GUISize; g++) {
				System.out.println("------------------Mining pattern " + (g + 1) + " -----------------------");
				// 3. find first clusters to start with
				// choose candidate clusters containing most freq edge not covered yet
				System.out.println("STEP 3: finding candidate closure");
				Float bestEdgeWt = Collections.max(DBEdge_wt);
				int bestEdgeIndex = DBEdge_wt.indexOf(bestEdgeWt);
				String mostFreqEdge = DBEdgeLabel.get(bestEdgeIndex);
				System.out.println("DBEdgeLabel: " + DBEdgeLabel.toString());
				System.out.println("DBEdge_wt: " + DBEdge_wt.toString());
				System.out.println("mostFreqEdge: " + mostFreqEdge + " bestEdgeWt: " + bestEdgeWt);
				// if(true) return ;
				Long startTime = System.currentTimeMillis();
				ArrayList<Integer> candidateClosureIndex = PM_getCandidateClosureIndex(mostFreqEdge, 1);// no threading
																										// here
				Long endTime = System.currentTimeMillis();
				System.out.println("get candidate closure index time: " + (endTime - startTime) + " ms");
				System.out.println("candidateClosureIndex: [" + candidateClosureIndex.size() + "] "
						+ candidateClosureIndex.toString());

				// 4. for each candidate cluster, find the best patterns
				// PM_findBestPatternOfClosure(candidateClosureIndex,
				// patternSetInfo.getPatternSizeMin(), patternSetInfo.getPatternSizeMax(),
				// GUIPatternSize, GUIPatternSizeCounter, GUISize, databaseInfo);
				PM_findBestPatternOfClosure(candidateClosureIndex, minCannedPatternSize, maxCannedPatternSize,
						GUIPatternSize, GUIPatternSizeCounter, GUISize);

				if (candidatePatterns.size() > 0) {
					// 5. collapse candidatePatterns to distinct ones
					PRINT = true;
					// PM_collapseCandidatePatterns(candidatePatterns,
					// candidatePatterns_closureIndex,
					// patternSetInfo.getPatternSizeMax()-patternSetInfo.getPatternSizeMax()+1,
					// PRINT);
					//System.out.println("distinctCandidatePatternssize:"+distinctCandidatePatterns.size());
				    //System.out.println("GUIPatternsssize:"+GUIPatterns.size());
					PM_collapseCandidatePatterns(candidatePatterns, candidatePatterns_closureIndex,
							maxCannedPatternSize - minCannedPatternSize + 1, PRINT);
					//System.out.println("distinctCandidatePatternssize:"+distinctCandidatePatterns.size());
					//System.out.println("GUIPatternsssize:"+GUIPatterns.size());
					// 6. compute score of distinct candidate patterns:
					// patternScore=clusterWt*(1+GED)
					PM_computePatternScore(distinctCandidatePatterns, GUIPatterns, GUISize, GUIPatternSize.size());
					//System.out.println("distinctCandidatePatternssize:"+distinctCandidatePatterns.size());
					//System.out.println("GUIPatternsssize:"+GUIPatterns.size());
					//if(true) return;
					// 7. find best pattern based on score (highest patternScore)
					// System.out.println("dPattern wt (cluster only):
					// <"+distinctCandidatePatterns_score.size()+">
					// "+distinctCandidatePatterns_score.toString());
					// WriteFile wf=new WriteFile();
					// wf.writeToFile(distinctCandidatePatterns_score);
					int count = 0;
					while (count < distinctCandidatePatterns_score.size()) {
						if (distinctCandidatePatterns_score.get(count) == null) {
							distinctCandidatePatterns_score.remove(count);
							distinctCandidatePatterns.remove(count);
						} else
							count++;
					}
					double bestScore = Collections.max(distinctCandidatePatterns_score);
					int bestPatternIndex = distinctCandidatePatterns_score.indexOf(bestScore);
					System.out.println("bestPatternIndex: " + bestPatternIndex);
					ArrayList<closureEdge> bestPattern = distinctCandidatePatterns.get(bestPatternIndex);
					GUIPatterns.add(bestPattern);
					int bestPatternSize = bestPattern.size();
					// update GUIPatternSizeCounter
					int patternSize_index = GUIPatternSize.indexOf(bestPatternSize);
					if (patternSize_index != -1)
						GUIPatternSizeCounter.set(patternSize_index, GUIPatternSizeCounter.get(patternSize_index) + 1);
					// System.out.println("bestPattern");
					// for(int i=0; i<bestPattern.size(); i++)
					// bestPattern.get(i).print();

					// 8. update weights of edge label and clusters based on best pattern selected
					PM_updateWeights(bestPattern, distinctCandidatePatterns_closureIndex.get(bestPatternIndex));
				} else
					g = GUISize;
			}
		}

		Long generatePatternEndTime = System.currentTimeMillis();
		System.out.println(
				"finish generating pattern: time duration(ms)=" + (generatePatternEndTime - generatePatternStartTime));

		// process database-END
		 String pathToSaveImage = PM_resetThumbnailFolder();
		 PM_generateThumbnails(pathToSaveImage, GUIPatterns, dbName);
		 PM_loadThumbnails(pathToSaveImage);

		 PM_savePatternsToFile(pathToSaveImage, GUIPatterns);

		System.out.println("finish generating pattern");
		System.out.println("The generated patterns are in \\patterns\\thumbnails" );
	}

	private ArrayList<Integer> PM_getCandidateClosureIndex(String mostFreqEdge, int count) {
		ArrayList<Integer> candidateClosureIndex = new ArrayList<Integer>();
		for (int i = 0; i < closureGraphList.size(); i++) {
			JGraphtClosureGraph cGraph = closureGraphList.get(i);
			if (cGraph.getEdgeLabelList().contains(mostFreqEdge) == true) {
				for (int c = 0; c < count; c++)
					candidateClosureIndex.add(closureGraphIndexList.get(i));
			}
		}
		return candidateClosureIndex;
	}

	private ArrayList<ArrayList<Integer>> getPatternIndexForEachThread(int numSize, ArrayList<Integer> list) {
		ArrayList<ArrayList<Integer>> thread_listIndex = new ArrayList<ArrayList<Integer>>();

		for (int i = 0; i < numSize; i++) {
			ArrayList<Integer> thisThread_listIndex = new ArrayList<Integer>();
			for (int j = 0 + i; j < list.size(); j = j + numSize)
				thisThread_listIndex.add(j);
			thread_listIndex.add(thisThread_listIndex);
		}

		return thread_listIndex;
	}

	private void PM_collapseCandidatePatterns(ArrayList<ArrayList<closureEdge>> candidatePatterns,
			ArrayList<Integer> candidateClosureIndex, int numOfSizes, boolean PRINT) {
		// for each pattern size, we can assign to a thread.
		// if more pattern sizes than threads, then a thread will be assigned one or
		// more sizes.
		// ---------------------------------------------------------------------------
		// candidatePatterns is arranged in such as a way now:
		// [e.g., 3 patterns sizes and 10 closures]: candidatePatterns=P1 P2 P3 P4 P5 P6
		// P7 P8 P9 P10 ...PN where
		// P1 P2 P3 belongs to closure1, P4 P5 P6 belongs to closure2, P7 P8 P9 belongs
		// to closure3 etc.
		// P1=size1, P2=size2, P3=size3
		// P4=size1, P5=size2, P6=size3
		// P7=size1, P8=size2, P9=size3 etc.
		System.out.println("STEP 5: collapsing candidate patterns");
		Long startTime = System.currentTimeMillis();
		// divide load into np-threads
		int np = Runtime.getRuntime().availableProcessors();
		ArrayList<ArrayList<Integer>> thread_patternIndex = getPatternIndexForEachThread(numOfSizes,
				candidateClosureIndex);
		ArrayList<Thread> threadList = new ArrayList<Thread>();
		ArrayList<String> threadNameList = new ArrayList<String>();
		CollapsePatternThreadCompleteListener threadListener = new CollapsePatternThreadCompleteListener(
				thread_patternIndex, candidatePatterns, candidateClosureIndex, threadList, threadNameList);

		int count = 0;
		while (thread_patternIndex.size() > 0) {
			if (np > threadList.size()) {
				ArrayList<ArrayList<closureEdge>> thisThread_candidatePattern = new ArrayList<ArrayList<closureEdge>>();
				ArrayList<Integer> thisThread_candidateClosureIndex = new ArrayList<Integer>();
				ArrayList<Integer> thisThread_patternIndex = thread_patternIndex.get(0);
				for (int j = 0; j < thisThread_patternIndex.size(); j++) {
					if (candidatePatterns.size() > thisThread_patternIndex.get(j)) {
						thisThread_candidatePattern.add(candidatePatterns.get(thisThread_patternIndex.get(j)));
						thisThread_candidateClosureIndex.add(candidateClosureIndex.get(thisThread_patternIndex.get(j)));
					}
				}
				CollapsePatternThread t = new CollapsePatternThread(thisThread_candidatePattern,
						thisThread_candidateClosureIndex, count++, threadListener);
				Thread gpThread = new Thread(t);
				gpThread.start();
				threadNameList.add(t.getName());
				threadList.add(gpThread);
				thread_patternIndex.remove(0);
			}
		}
		for (int i = 0; i < threadList.size(); i++) {
			try {
				threadList.get(i).join();
			} catch (InterruptedException ex) {
				// Exceptions.printStackTrace(ex);
			}
		}
		boolean SOME_THREAD_STILL_ALIVE = false;
		for (int i = 0; i < threadList.size(); i++) {
			if (threadList.get(i).isAlive()) {
				SOME_THREAD_STILL_ALIVE = true;
				i = threadList.size();
			}
		}
		while (SOME_THREAD_STILL_ALIVE) {
			try {
				Thread.sleep(10);
				for (int i = 0; i < threadList.size(); i++) {
					if (threadList.get(i).isAlive()) {
						SOME_THREAD_STILL_ALIVE = true;
						i = threadList.size();
					}
				}
			} catch (InterruptedException ex) {
				// Exceptions.printStackTrace(ex);
			}
		}
		// System.out.println("all Collapse threads are DEAD!!! can proceed");

		distinctCandidatePatterns = threadListener.getDistinctPatterns();
		distinctCandidatePatterns_closureIndex = threadListener.getDistinctPatternsClosureIndex();
		System.out.println("distinctCandidatePatterns:" + distinctCandidatePatterns.size()
				+ " distinctCandidatePatterns_closureIndex:" + distinctCandidatePatterns_closureIndex.size());
		Long endTime = System.currentTimeMillis();
		System.out.println("collapse candidate pattern time: " + (endTime - startTime) + " ms");
		PRINT = false;
		if (PRINT) {
			System.out.println("******************** collapsing candidate patterns!! ");
			for (int i = 0; i < distinctCandidatePatterns.size(); i++) {
				System.out.println("Distinct pattern " + i + " ======= closure index: "
						+ distinctCandidatePatterns_closureIndex.get(i).toString());
				ArrayList<closureEdge> d = distinctCandidatePatterns.get(i);
				for (int j = 0; j < d.size(); j++)
					d.get(j).print();
			}
		}
	}

	private ArrayList<ArrayList<Integer>> PM_getCandidatePatternIndexForEachThread(int numThreads, int numPatterns) {
		// System.out.println("indexList: ["+indexList.size()+"]
		// "+indexList.toString());
		ArrayList<ArrayList<Integer>> thread_indexList = new ArrayList<ArrayList<Integer>>();
		int numBucketsWithExtras = numPatterns % numThreads;
		int defaultSize = (numPatterns - numBucketsWithExtras) / numThreads;
		int size;
		int count = 0;
		for (int i = 0; i < numThreads; i++) {
			if (i < numBucketsWithExtras)
				size = defaultSize + 1;
			else
				size = defaultSize;
			ArrayList<Integer> thisThread_indexList = new ArrayList<Integer>();
			for (int j = 0; j < size; j++)
				thisThread_indexList.add(count + j);
			/*
			 * if(size>80) //fix each thread as 80 patterns { int numIndexToRemove=size-80;
			 * int counter=0; while(counter<numIndexToRemove) { Random rand=new Random();
			 * int indexToRemove=rand.nextInt(thisThread_indexList.size());
			 * thisThread_indexList.remove(indexToRemove); counter++; } }
			 */
			thread_indexList.add(thisThread_indexList);
			count = count + size;
		}
		// UNCOMMENT for debugging
		/*
		 * System.out.println("PM_getCandidatePatternIndexForEachThread count "+count);
		 * for(int i=0; i<thread_indexList.size(); i++) { ArrayList<Integer>
		 * iList=thread_indexList.get(i); System.out.println("Thread "+i+": "); for(int
		 * j=0; j<iList.size(); j++) System.out.print(iList.get(j)+" "); }
		 */
		return thread_indexList;
	}

	private void PM_computePatternScore(ArrayList<ArrayList<closureEdge>> patternList,
			ArrayList<ArrayList<closureEdge>> GUIPatterns, int GUISize, int binNum) {
		System.out.println("STEP 6a: compute pattern score for candidate patterns");
		Long startTime = System.currentTimeMillis();
		int np = Runtime.getRuntime().availableProcessors() - 2;
		// int np=1;
		System.out.println("PM_findBestPatternOfClosure numProcessors available=" + np);
		// divide load into np-threads
		ArrayList<Thread> score_threadList = new ArrayList<Thread>();
		ComputeScoreThreadCompleteListener threadListener = new ComputeScoreThreadCompleteListener();
		ArrayList<ArrayList<Integer>> thread_candidatePatternIndex = PM_getCandidatePatternIndexForEachThread(np,
				patternList.size());

		for (int i = 0; i < np; i++) {
			ComputeScoreThread t = new ComputeScoreThread(thread_candidatePatternIndex.get(i),
					distinctCandidatePatterns, distinctCandidatePatterns_closureIndex, GUIPatterns, c_wt, i,
					threadListener, GUISize, binNum);

			Thread pThread = new Thread(t, t.getName());
			pThread.start();
			score_threadList.add(pThread);
		}
		try {
			for (int i = 0; i < np; i++) {
				// System.out.println(score_threadList.get(i).getName()+" joins");
				score_threadList.get(i).join();
			}
		} catch (InterruptedException ex) {
			// Exceptions.printStackTrace(ex);
		}

		boolean SOME_THREAD_STILL_ALIVE = false;
		for (int i = 0; i < score_threadList.size(); i++) {
			if (score_threadList.get(i).isAlive()) {
				SOME_THREAD_STILL_ALIVE = true;
				i = score_threadList.size();
			}
		}
		while (SOME_THREAD_STILL_ALIVE) {
			try {
				Thread.sleep(10);
				for (int i = 0; i < score_threadList.size(); i++) {
					if (score_threadList.get(i).isAlive()) {
						SOME_THREAD_STILL_ALIVE = true;
						i = score_threadList.size();
					}
				}
			} catch (InterruptedException ex) {
				// Exceptions.printStackTrace(ex);
			}
		}
		System.out.println("all score threads are DEAD!!! can proceed");

		System.out.println("candidatePatterns: " + candidatePatterns.size());
		Long endTime = System.currentTimeMillis();
		System.out.println("compute score time: " + (endTime - startTime) + " ms");
		// Long stopTime=System.currentTimeMillis();
		// System.out.println("time taken:"+ (stopTime-startTime)+" ms");
		// System.out.println("candidatePatterns: "+candidatePatterns.size());
		// for(int i=0; i<=15; i++)
		// {
		// ArrayList<closureEdge> p=candidatePatterns.get(i);
		// System.out.println("pattern "+i);
		// for(int j=0; j<p.size(); j++)
		// p.get(j).print();
		// }

		distinctCandidatePatterns = threadListener.getCandidatePatterns();
		distinctCandidatePatterns_score = threadListener.getCandidatePatternScore();
		// System.out.println("distinctCandidatePatterns_score:
		// "+distinctCandidatePatterns_score.toString());
		distinctCandidatePatterns_closureIndex = threadListener.getCandidatePatternClosureIndex();
	}

	private void PM_savePatternsToFile(String folderPath, ArrayList<ArrayList<closureEdge>> GUIPattern)
			throws IOException {
		String outputFilename = folderPath + "\\GUIPatterns.txt";

		try {
			BufferedWriter bufWriter = new BufferedWriter(new FileWriter(outputFilename));
			for (int i = 0; i < GUIPattern.size(); i++) {
				ArrayList<closureEdge> thisPattern = GUIPattern.get(i);
				ArrayList<closureVertex> thisPattern_vList = new ArrayList<closureVertex>();
				for (int j = 0; j < thisPattern.size(); j++) {
					closureEdge e = thisPattern.get(j);
					closureVertex s = e.getSource();
					closureVertex t = e.getTarget();
					if (thisPattern_vList.contains(s) == false)
						thisPattern_vList.add(s);
					if (thisPattern_vList.contains(t) == false)
						thisPattern_vList.add(t);
				}
				// write header
				bufWriter.write("t # " + i + " " + thisPattern_vList.size());
				bufWriter.newLine();
				// write vertices
				for (int j = 0; j < thisPattern_vList.size(); j++) {
					closureVertex v = thisPattern_vList.get(j);
					String v_label = v.getLabel().get(0);
					bufWriter.write("v " + j + " " + v_label);
					bufWriter.newLine();
				}
				// write edges
				for (int j = 0; j < thisPattern.size(); j++) {
					closureEdge e = thisPattern.get(j);
					closureVertex s = e.getSource();
					closureVertex t = e.getTarget();
					int s_index = thisPattern_vList.indexOf(s);
					int t_index = thisPattern_vList.indexOf(t);
					if (s_index < t_index)
						bufWriter.write("e " + s_index + " " + t_index + " 0");
					else
						bufWriter.write("e " + t_index + " " + s_index + " 0");
					bufWriter.newLine();
				}
				bufWriter.newLine();
			}

			System.out.println("all done!");
			bufWriter.close();
		} catch (FileNotFoundException e) {
			e.printStackTrace();
		}
	}

	private ArrayList<ArrayList<Object>> loadImagesFromFolder(String _freqFolderPath) {

		File file = new File(_freqFolderPath);
		File[] fileList = file.listFiles();
		ArrayList<ArrayList<Object>> imageArray = new ArrayList<ArrayList<Object>>();
		int numOfCol = 2;
		int numOfRow = Math.floorDiv(fileList.length + 1, numOfCol);

		for (int i = 0; i < numOfRow; i++) {
			ArrayList<Object> rowElement = new ArrayList<Object>();
			for (int j = 0; j < numOfCol; j++) {

				// int iconIndex = i * numPerRow + j;
				int imageIndex = i * numOfCol + j;
				if (imageIndex < fileList.length) {
					String idStr = fileList[imageIndex].getName().substring(0,
							fileList[imageIndex].getName().length() - 4);
					int patId = Integer.parseInt(idStr);
					DnDImage tmpButton = new DnDImage(fileList[imageIndex].getAbsolutePath(), patId);
					System.out.println("[loadImagesFromFolder] " + i + ", " + j + " file:"
							+ fileList[imageIndex].getAbsolutePath());
					rowElement.add(tmpButton);
				}
			}
			imageArray.add(rowElement);
		}
		return imageArray;
	}

	public void putUpPatterns(String _patternType, int columnSize, Object[][] data) {
		int Width = 150;
		Object[] columnNames = new Object[columnSize];
		for (int i = 0; i < columnNames.length; i++) {
			columnNames[i] = "";
		}

		ThumbnailTable table = new ThumbnailTable(columnNames, data, Width / columnSize);
		// patternPanel.remove(patternScrollPane);
		// patternScrollPane = new JScrollPane(table);
		// patternPanel.add(patternScrollPane, BorderLayout.CENTER);

		// patternPanel.revalidate();
	}

	private void PM_loadThumbnails(String imageFolderPath) {
		ArrayList<ArrayList<Object>> thumbnailTable = loadImagesFromFolder(imageFolderPath);
		int numOfRows = thumbnailTable.size();
		int numOfColumns = thumbnailTable.get(0).size();
		// System.out.println("PM_loadThumbnails numOfRows:"+numOfRows+"
		// numOfColumns:"+numOfColumns);
		Object[][] thumbnailTableObj = new Object[numOfRows][numOfColumns];
		for (int i = 0; i < thumbnailTable.size(); i++) {
			for (int j = 0; j < thumbnailTable.get(i).size(); j++) {
				thumbnailTableObj[i][j] = thumbnailTable.get(i).get(j);
			}
		}

		putUpPatterns("thumbnail", numOfColumns, thumbnailTableObj);
		System.out.println("PM_loadThumbnails => Pattern images loaded!");
	}

	private void PM_generateThumbnails(String pathToSaveImage, ArrayList<ArrayList<closureEdge>> GUIPatterns,
			String database) throws IOException {
		int patternId = 0;
		for (int x = 0; x < GUIPatterns.size(); x++) {
			Graph tmpPattern = new Graph();

			ArrayList<closureEdge> p = GUIPatterns.get(x);
			System.out.println("GUI Pattern " + x);
			for (int i = 0; i < p.size(); i++)
				p.get(i).print();
			ArrayList<closureVertex> p_vList = new ArrayList<closureVertex>();
			int edgeNum = p.size();
			// preprocess to get distinct nodes
			for (int i = 0; i < edgeNum; i++) {
				closureEdge e = p.get(i);
				closureVertex s = e.getSource();
				closureVertex t = e.getTarget();
				if (p_vList.contains(s) == false)
					p_vList.add(s);
				if (p_vList.contains(t) == false)
					p_vList.add(t);
			}
			// Add nodes to temp pattern
			ArrayList<Integer> nodeIDLookUp = new ArrayList<Integer>();
			int vertexNum = p_vList.size();
			for (int i = 0; i < vertexNum; i++) {
				String nodeLabel = p_vList.get(i).getLabel().get(0);
				Vertex node = new Vertex();
				node.setLabel(nodeLabel);
				node.setID(i);
				nodeIDLookUp.add(p_vList.get(i).getID());
				// node.setID(p_vList.get(i).getID());

				tmpPattern.addNode(node);
			}
			// Add edges to temp pattern
			for (int i = 0; i < edgeNum; i++) {
				closureEdge e = p.get(i);
				closureVertex s = e.getSource();
				closureVertex t = e.getTarget();
				int s_ID = s.getID();
				int t_ID = t.getID();
				int e1 = nodeIDLookUp.indexOf(s_ID);
				int e2 = nodeIDLookUp.indexOf(t_ID);
				tmpPattern.addEdge(e1, e2);
				tmpPattern.getNode(e1).setIn(e2);
				tmpPattern.getNode(e2).setIn(e1);
				tmpPattern.getNode(e1).incDegree();
				tmpPattern.getNode(e2).incDegree();
				if (p_vList.contains(s) == false)
					p_vList.add(s);
				if (p_vList.contains(t) == false)
					p_vList.add(t);
			}

			// Set number of vertices and number of edges of the temp pattern
			tmpPattern.setVertexNum(vertexNum);
			tmpPattern.setEdgeNum(edgeNum);

			try {
				generatePatternImage(tmpPattern, patternId, pathToSaveImage, database);
			} catch (ClassNotFoundException ex) {
				// Exceptions.printStackTrace(ex);
			}
			patternId++;
		}
	}

	void generatePatternImage(Graph tmpPattern, int patternId, String imagePatternPath, String database)
			throws ClassNotFoundException, IOException {

		dotGenerator.createGraph(tmpPattern, database);
		dotGenerator.formatDotFile(patternId);

		// String cmdGeneratePNG = "cmd /c dot -Tpng -Kneato -Gepsilon=0.0001
		// patterns/temp_pattern.dot -o " + imagePatternPath +
		// Integer.toString(patternId) + ".png";
		String cmdGeneratePNG = "cmd /c dot -Tpng  -Kneato -Gepsilon=0.0001 patterns/temp_pattern.dot -o "
				+ imagePatternPath + Integer.toString(patternId) + ".png";
		// String cmdGeneratePNG = "cmd /c dot -Tpng -Kneato -Gepsilon=0.0001
		// patterns/temp_pattern.dot -o " + imagePatternPath +
		// Integer.toString(patternId) + ".png";
		// String cmdGenerateJPG = "cmd /c dot -Tjpg -Kneato -Gepsilon=0.0001
		// patterns/temp_pattern.dot -o " + imagePatternPath +
		// Integer.toString(patternId) + ".jpg";
		// String cmdGenerateSVG = "cmd /c dot -Tsvg -Kneato -Gepsilon=0.0001
		// patterns/temp_pattern.dot -o " + imagePatternPath +
		// Integer.toString(patternId) + ".svg";

		try {
			// System.out.println("generatePatternImage!!
			// imagePatternPath:"+imagePatternPath);
			System.out.println("cmdGeneratePNG:" + cmdGeneratePNG);
			Process procPNG = Runtime.getRuntime().exec(cmdGeneratePNG);
			// Process procJPG = Runtime.getRuntime().exec(cmdGenerateJPG);
			// Process procSVG = Runtime.getRuntime().exec(cmdGenerateSVG);
			/*
			 * BufferedReader stdInput = new BufferedReader(new
			 * InputStreamReader(procPNG.getInputStream()));
			 * 
			 * Checking output of cmd running from java BufferedReader stdError = new
			 * BufferedReader(new InputStreamReader(procPNG.getErrorStream())); String s =
			 * ""; // read the output from the command
			 * System.out.println("Here is the standard output of the command:\n"); while
			 * ((s = stdInput.readLine()) != null) { System.out.println(s); }
			 * 
			 * // read any errors from the attempted command
			 * System.out.println("Here is the standard error of the command (if any):\n");
			 * while ((s = stdError.readLine()) != null) { System.out.println(s); }
			 */

			procPNG.waitFor();
			// procJPG.waitFor();
			// procSVG.waitFor();
			// Process procSVG = Runtime.getRuntime().exec(cmdGenerateSVG);
			// procSVG.waitFor();
		} catch (InterruptedException ex) {
			throw new RuntimeException(ex);
		}
	}

	private String PM_resetThumbnailFolder() throws IOException {
		String thumbnailFolderPath = "patterns\\thumbnails\\";
		// Create fresh ./patterns/image folder
		String cmdDeleteImageFolder = "cmd /c rmdir /Q /S " + thumbnailFolderPath;
		String cmdcmdMakeImageFolder = "cmd /c mkdir " + thumbnailFolderPath;
		try {
			Process procDeleteImageFolder = Runtime.getRuntime().exec(cmdDeleteImageFolder);
			procDeleteImageFolder.waitFor();
			Process procmdMakeImageFolder = Runtime.getRuntime().exec(cmdcmdMakeImageFolder);
			procmdMakeImageFolder.waitFor();
		} catch (InterruptedException ex) {
			throw new RuntimeException(ex);
		}
		return thumbnailFolderPath;
	}

	private void PM_updateWeights(ArrayList<closureEdge> selectedPattern, ArrayList<Integer> pattern_clusterIndex) {
		Float n = 0.5f;
		// System.out.println("------------------------------------------------");
		// System.out.println("pattern_clusterIndex:"+pattern_clusterIndex.toString());
		// for(int i=0; i<selectedPattern.size(); i++)
		// selectedPattern.get(i).print();
		// System.out.println("------------------------------------------------");
		// System.out.println("updating weights");
		// System.out.println("BEFORE c_wt: "+c_wt.toString());
		// System.out.println("pattern_clusterIndex: "+pattern_clusterIndex.toString());
		// 1. update cluster weight by decrementing by factor of 1-n where n=0.5
		for (int i = 0; i < pattern_clusterIndex.size(); i++) {
			int index = pattern_clusterIndex.get(i);
			Float wt = c_wt.get(index);
			Float new_wt = (1 - n) * wt;
			c_wt.set(index, new_wt);
		}
		// System.out.println("AFTER c_wt: "+c_wt.toString());

		// 2. update edge weight by decrementing by factor of 1-n where n=0.5
		// System.out.println("BEFORE DBEdge_wt: "+DBEdge_wt.toString());
		ArrayList<Integer> edgeIndexUpdated = new ArrayList<Integer>();
		for (int i = 0; i < selectedPattern.size(); i++) {
			closureEdge e = selectedPattern.get(i);
			String e_str = e.getEdgeLabelString();
			int index = DBEdgeLabel.indexOf(e_str);
			if (edgeIndexUpdated.contains(index) == false)
				edgeIndexUpdated.add(index);
			float wt = DBEdge_wt.get(index);
			float new_wt = (1 - n) * wt;
			DBEdge_wt.set(index, new_wt);
		}
		// System.out.println("updated index: "+edgeIndexUpdated.toString());
		// System.out.println("AFTER DBEdge_wt: "+DBEdge_wt.toString());

	}

	private ArrayList<ArrayList<Integer>> PM_getCandidateClosureIndexForEachThread(int numThreads,
			ArrayList<Integer> indexList) {
		// System.out.println("indexList: ["+indexList.size()+"]
		// "+indexList.toString());
		ArrayList<ArrayList<Integer>> thread_indexList = new ArrayList<ArrayList<Integer>>();
		int numBucketsWithExtras = indexList.size() % numThreads;
		int defaultSize = (indexList.size() - numBucketsWithExtras) / numThreads;
		int size;
		int count = 0;
		for (int i = 0; i < numThreads; i++) {
			if (i < numBucketsWithExtras)
				size = defaultSize + 1;
			else
				size = defaultSize;
			ArrayList<Integer> thisThread_indexList = new ArrayList<Integer>();
			for (int j = 0; j < size; j++)
				thisThread_indexList.add(indexList.get(count + j));
			thread_indexList.add(thisThread_indexList);
			count = count + size;
		}
		// UNCOMMENT for debugging
		// System.out.println("count "+count);
		/*
		 * for(int i=0; i<thread_indexList.size(); i++) { ArrayList<Integer>
		 * iList=thread_indexList.get(i); System.out.println("Thread "+i+": "); for(int
		 * j=0; j<iList.size(); j++) System.out.print(iList.get(j)+" "); }
		 */
		return thread_indexList;
	}

	private void PM_findBestPatternOfClosure(ArrayList<Integer> candidateClosureIndex, int minPatternSize,
			int maxPatternSize, ArrayList<Integer> GUIPatternSize, ArrayList<Integer> GUIPatternSizeCounter,
			int maxPatternPerSize) {
		System.out.println("STEP 4: nominate best patterns for each candidate closure");
		Long startTime = System.currentTimeMillis();
		candidatePatterns = new ArrayList<ArrayList<closureEdge>>();
		candidatePatterns_closureIndex = new ArrayList<Integer>();
		int np = Runtime.getRuntime().availableProcessors();
		// int np=1;

		// System.out.println("PM_findBestPatternOfClosure numProcessors
		// available="+np);
		// Long startTime=System.currentTimeMillis();
		// divide load into np-threads
		ArrayList<Thread> pattern_threadList = new ArrayList<Thread>();
		GeneratePatternThreadCompleteListener threadListener = new GeneratePatternThreadCompleteListener(
				candidatePatterns, candidatePatterns_closureIndex);
		ArrayList<ArrayList<Integer>> thread_candidateClosureIndex = PM_getCandidateClosureIndexForEachThread(np,
				candidateClosureIndex);

		System.out.println("closureGraphList size: " + closureGraphList.size());
		for (int i = 0; i < np; i++) {
			GeneratePatternThread t = new GeneratePatternThread(closureGraphList, thread_candidateClosureIndex.get(i),
					DBEdgeLabel, DBEdge_wt, minPatternSize, maxPatternSize, i, threadListener, GUIPatternSize,
					GUIPatternSizeCounter, maxPatternPerSize, DBVertexLabel, DBVertexLabelValency);
			Thread pThread = new Thread(t, t.getName());
			pThread.start();
			pattern_threadList.add(pThread);
		}
		try {
			for (int i = 0; i < np; i++) {
				// System.out.println(pattern_threadList.get(i).getName()+" joins");
				pattern_threadList.get(i).join();
			}
		} catch (InterruptedException ex) {
			// Exceptions.printStackTrace(ex);
		}

		boolean SOME_THREAD_STILL_ALIVE = false;
		for (int i = 0; i < pattern_threadList.size(); i++) {
			if (pattern_threadList.get(i).isAlive()) {
				SOME_THREAD_STILL_ALIVE = true;
				i = pattern_threadList.size();
			}
		}
		while (SOME_THREAD_STILL_ALIVE) {
			try {
				Thread.sleep(10);
				for (int i = 0; i < pattern_threadList.size(); i++) {
					if (pattern_threadList.get(i).isAlive()) {
						SOME_THREAD_STILL_ALIVE = true;
						i = pattern_threadList.size();
					}
				}
			} catch (InterruptedException ex) {
				// Exceptions.printStackTrace(ex);
			}
		}
		System.out.println("all pattern threads are DEAD!!! can proceed");
		/*
		 * Object obj = new Object(); try { synchronized (obj) { while
		 * (pattern_threadList.size()>0) {//Or any Loops //Do Something
		 * //System.out.println("no. of active threads left: "+pattern_threadList.size()
		 * ); obj.wait(10);//Sample obj.wait(1000); 1 second sleep } } } catch
		 * (InterruptedException ex) { //SomeFishCatching }
		 */
		System.out.println("candidatePatterns: " + candidatePatterns.size());
		Long endTime = System.currentTimeMillis();
		System.out.println("nominate candidate pattern time: " + (endTime - startTime) + " ms");
		// Long stopTime=System.currentTimeMillis();
		// System.out.println("time taken:"+ (stopTime-startTime)+" ms");
		// System.out.println("candidatePatterns: "+candidatePatterns.size());
		// for(int i=0; i<=15; i++)
		// {
		// ArrayList<closureEdge> p=candidatePatterns.get(i);
		// System.out.println("pattern "+i);
		// for(int j=0; j<p.size(); j++)
		// p.get(j).print();
		// }

		candidatePatterns = threadListener.getCandidatePatterns();
		candidatePatterns_closureIndex = threadListener.getCandidatePatternClosureIndex();
	}

	private ArrayList<ArrayList<Integer>> readClusterFile(String fileName) {
		String strLine = null;
		File fin = new File(fileName);
		BufferedReader br;
		String delimiter = "\t";
		int counter = 0;
		ArrayList<ArrayList<Integer>> clusterGraphID = new ArrayList<ArrayList<Integer>>();
		try {
			br = new BufferedReader(new InputStreamReader(new BufferedInputStream(new FileInputStream(fin))));
			while ((strLine = br.readLine()) != null) {
				// there are some lines to be ignored...these contains ":"
				if (!strLine.contains(":")) {
					// each line is a cluster and the items in each line is the graph id (delimited
					// by space)
					counter++;
					System.out.println("Cluster " + counter + ": " + strLine);
					ArrayList<Integer> aCluster = new ArrayList<Integer>();
					int spaceIndex = strLine.indexOf(delimiter);
					while (spaceIndex != -1) {
						int graphId = Integer.parseInt(strLine.substring(0, spaceIndex));
						strLine = strLine.substring(spaceIndex + 1);
						spaceIndex = strLine.indexOf(delimiter);
						aCluster.add(graphId);
						if (fullyContainedGraphID.contains(graphId) == false)
							fullyContainedGraphID.add(graphId);
					}
					clusterGraphID.add(aCluster);
				}
			}
			br.close();
			// System.out.println("clusterGraphID.size="+clusterGraphID.size());
			// for(int i=0; i<clusterGraphID.size(); i++)
			// System.out.println(i+": "+clusterGraphID.get(i).toString());
		} catch (Exception ex) {
			System.out.println("Exception: ");
			ex.printStackTrace();
		}
		System.out.println("All graph id list: " + fullyContainedGraphID.size());
		return clusterGraphID;
	}

	private int PM_generateClusterClosure(String filename, ArrayList<ArrayList<Integer>> original_clusterIDList) {
		System.out.println("STEP 2: generating graph closure");
		Long startTime = System.currentTimeMillis();
		int np = Runtime.getRuntime().availableProcessors();
		System.out.println("PM_findBestPatternOfClosure numProcessors available=" + np);
		// Long startTime=System.currentTimeMillis();
		int totalGraphs = 0;
		for (int i = 0; i < original_clusterIDList.size(); i++) {
			// System.out.println("Cluster "+i+":
			// "+original_clusterIDList.get(i).toString());
			totalGraphs = totalGraphs + original_clusterIDList.get(i).size();
			// System.out.println("Number of totalGraphs:"+ Integer.toString(totalGraphs));
		}
		// divide load into np-threads
		ArrayList<String> dbEdgeLabels = new ArrayList<String>();
		ArrayList<Integer> dbEdgeLabelsFreq = new ArrayList<Integer>();
		ArrayList<String> dbVertexLabels = new ArrayList<String>();
		ArrayList<Integer> dbVertexLabelValency = new ArrayList<Integer>();
		GenerateClosureThreadCompleteListener threadListener = new GenerateClosureThreadCompleteListener();
		// get Graph ID For Each Thread
		ArrayList<ArrayList<ArrayList<Integer>>> thread_closureGraphIndex = getClosureGraphIDForEachThread(np,
				original_clusterIDList);
		// get Closure ID For Each Thread
		ArrayList<ArrayList<Integer>> thread_closureIndex = getClosureIndexForEachThread(np, original_clusterIDList);
		ArrayList<Thread> threadList = new ArrayList<Thread>();

		for (int i = 0; i < thread_closureIndex.size(); i++)
			System.out.println(i + ": " + thread_closureIndex.get(i).toString());
		for (int i = 0; i < np; i++) {
			GenerateClosureThread t = new GenerateClosureThread(filename, thread_closureGraphIndex.get(i),
					thread_closureIndex.get(i), i, threadListener);
			Thread gpThread = new Thread(t, t.getName());
			gpThread.start();
			threadList.add(gpThread);
			// if(true) return 0;
		}
		try {
			for (int i = 0; i < np; i++) {
				threadList.get(i).join();
				// System.out.println(threadList.get(i).getName()+" join");
			}
		} catch (InterruptedException ex) {
			// Exceptions.printStackTrace(ex);
		}
		boolean SOME_THREAD_STILL_ALIVE = false;
		for (int i = 0; i < threadList.size(); i++) {
			if (threadList.get(i).isAlive()) {
				SOME_THREAD_STILL_ALIVE = true;
				i = threadList.size();
			}
		}
		while (SOME_THREAD_STILL_ALIVE) {
			try {
				Thread.sleep(10);
				for (int i = 0; i < threadList.size(); i++) {
					if (threadList.get(i).isAlive()) {
						SOME_THREAD_STILL_ALIVE = true;
						i = threadList.size();
					}
				}
			} catch (InterruptedException ex) {
				// Exceptions.printStackTrace(ex);
			}
		}
		System.out.println("all Closure threads are DEAD!!! can proceed");
		dbEdgeLabels = threadListener.getDBEdgeLabel();
		dbEdgeLabelsFreq = threadListener.getDBEdgeLabelFreq();
		dbVertexLabels = threadListener.getDBVertexLabel();
		dbVertexLabelValency = threadListener.getDBVertexLabelValency();
		Comparator<DBStat> comparator = new DBStatComparator();
		PriorityQueue<DBStat> DBStatEdgeLabels;// the unique edge labels found in the graphs in the DB and the no. of
												// graphs having that edge label. Sorted in decreasing frequency
		DBStatEdgeLabels = new PriorityQueue<DBStat>(dbEdgeLabels.size(), comparator);
		for (int i = 0; i < dbEdgeLabels.size(); i++) {
			DBStat e_stat = new DBStat(dbEdgeLabels.get(i), dbEdgeLabelsFreq.get(i));
			DBStatEdgeLabels.add(e_stat);
		}
		for (int i = 0; i < dbEdgeLabels.size(); i++) {
			DBStat e_stat = DBStatEdgeLabels.poll();
			DBEdgeLabel.add(e_stat.getLabel());
			DBEdgeLabelFreq.add(e_stat.getFreq());
		}
		for (int i = 0; i < dbVertexLabels.size(); i++) {
			String vLabel = dbVertexLabels.get(i);
			int vLabel_index = DBVertexLabel.indexOf(vLabel);
			if (vLabel_index == -1) {
				DBVertexLabel.add(vLabel);
				DBVertexLabelValency.add(dbVertexLabelValency.get(i));
			} else {
				if (DBVertexLabelValency.get(vLabel_index) < dbVertexLabelValency.get(i))
					DBVertexLabelValency.set(vLabel_index, dbVertexLabelValency.get(i));
			}
		}

		System.out.println("DBVertexLabel: " + DBVertexLabel.toString());
		System.out.println("DBVertexLabelValency: " + DBVertexLabelValency.toString());

		maxClosureSize = threadListener.getMaxClosureSize();
		closureGraphList = threadListener.getClosureGraph();
		closureGraphIndexList = threadListener.getClosureGraphIndex();

		Long endTime = System.currentTimeMillis();
		System.out.println("closure generation time: " + (endTime - startTime) + " ms");

		System.out.println("DBEdgeLabel:" + DBEdgeLabel.toString());
		System.out.println("DBEdgeLabelFreq:" + DBEdgeLabelFreq.toString());
		System.out.println("!!!!!!!!!! No. of distinct edge labels=" + DBEdgeLabel.size());

		// return threadListener.getTotalGraphs();
		return totalGraphs;
	}

	private ArrayList<ArrayList<ArrayList<Integer>>> getClosureGraphIDForEachThread(int numThreads,
			ArrayList<ArrayList<Integer>> indexList) {
		// System.out.println("indexList: ["+indexList.size()+"]
		// "+indexList.toString());
		ArrayList<ArrayList<ArrayList<Integer>>> thread_indexList = new ArrayList<ArrayList<ArrayList<Integer>>>();
		int numBucketsWithExtras = indexList.size() % numThreads;
		int defaultSize = (indexList.size() - numBucketsWithExtras) / numThreads;
		int size;
		int count = 0;
		for (int i = 0; i < numThreads; i++) {
			if (i < numBucketsWithExtras)
				size = defaultSize + 1;
			else
				size = defaultSize;
			ArrayList<ArrayList<Integer>> thisThread_indexList = new ArrayList<ArrayList<Integer>>();
			for (int j = 0; j < size; j++)
				thisThread_indexList.add(indexList.get(count + j));
			thread_indexList.add(thisThread_indexList);
			count = count + size;
		}
		// UNCOMMENT for debugging
		// System.out.println("count "+count);
		/*
		 * for(int i=0; i<thread_indexList.size(); i++) { ArrayList<Integer>
		 * iList=thread_indexList.get(i); System.out.println("Thread "+i+": "); for(int
		 * j=0; j<iList.size(); j++) System.out.print(iList.get(j)+" "); }
		 */
		return thread_indexList;
	}

	private ArrayList<ArrayList<Integer>> getClosureIndexForEachThread(int numThreads,
			ArrayList<ArrayList<Integer>> indexList) {
		// System.out.println("indexList: ["+indexList.size()+"]
		// "+indexList.toString());
		ArrayList<ArrayList<Integer>> thread_indexList = new ArrayList<ArrayList<Integer>>();
		int numBucketsWithExtras = indexList.size() % numThreads;
		int defaultSize = (indexList.size() - numBucketsWithExtras) / numThreads;
		int size;
		int count = 0;
		for (int i = 0; i < numThreads; i++) {
			if (i < numBucketsWithExtras)
				size = defaultSize + 1;
			else
				size = defaultSize;
			ArrayList<Integer> thisThread_indexList = new ArrayList<Integer>();
			for (int j = 0; j < size; j++)
				thisThread_indexList.add(count + j);
			thread_indexList.add(thisThread_indexList);
			count = count + size;
		}
		// UNCOMMENT for debugging
		// System.out.println("count "+count);
		/*
		 * for(int i=0; i<thread_indexList.size(); i++) { ArrayList<Integer>
		 * iList=thread_indexList.get(i); System.out.println("Thread "+i+": "); for(int
		 * j=0; j<iList.size(); j++) System.out.print(iList.get(j)+" "); }
		 */
		return thread_indexList;
	}
}
